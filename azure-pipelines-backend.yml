# azure-pipelines-backend.yml
trigger:
  branches:
    include:
      - main
      - release/*
  tags:
    include:
      - v*
  paths:
    include:
      - backend/*

pr:
  branches:
    include:
      - main
  paths:
    include:
      - backend/*
      - k8s/dev-backend/*

variables:
  - group: aws-credentials
  - group: cosign-secrets
  - name: AWS_REGION
    value: us-east-2

  - name: EKS_CLUSTER_NAME
    value: capstone-project

  # ECR registry base
  - name: ECR_REGISTRY
    value: $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com

  # Repo name in ECR
  - name: IMAGE_NAME
    value: capstone-project-backend

  # Tag: commit SHA
  - name: IMAGE_TAG
    value: $(Build.SourceVersion)



stages:
  - stage: PRChecks
    displayName: PR Fast Checks
    condition: eq(variables['Build.Reason'], 'PullRequest')
    jobs:
      - job: LintAndTest
        displayName: Lint & Test
        pool:
          name: Default
        steps:
          - template: devops/templates/python-pr-checks.yml

  - stage: BuildAndRelease
    displayName: SBOM (source) → Build → Scan → Push → Sign
    condition: ne(variables['Build.Reason'], 'PullRequest')
    jobs:
      - job: Build
        displayName: Backend Build + Security + Push
        pool:
          name: Default
        steps:
          - script: |
              echo "Build.Reason=$(Build.Reason)"
              echo "Build.SourceBranch=$(Build.SourceBranch)"
              echo "Build.SourceBranchName=$(Build.SourceBranchName)"
            displayName: "Debug branch variables"

          - checkout: self
            persistCredentials: true


          # 1) SBOM for backend SOURCE code/dependencies (NOT docker image)
          - template: pipelines/templates/docker/sbom-syft.yml
            parameters:
              sourcePath: backend
              outputFormats: "spdx-json cyclonedx-json"
              attachToImage: false
              artifactName: "sbom-backend-src-$(Build.BuildId)"

          # 2) Build docker image locally (BuildKit)
          - template: pipelines/templates/docker/build-docker.yml
            parameters:
              imageName: "$(IMAGE_NAME)"
              imageTag: "$(IMAGE_TAG)"
              dockerfilePath: backend/Dockerfile
              buildContext: backend
              enableCache: true
              cacheRegistry: "$(ECR_REGISTRY)"
              buildArgs: ""

          # 3) Trivy scan the LOCAL image (before push)
          - template: pipelines/templates/docker/scan-trivy.yml
            parameters:
              imageName: "$(IMAGE_NAME)"
              imageTag: "$(IMAGE_TAG)"
              severityThreshold: "CRITICAL,HIGH"
              failOnVulnerabilities: true
              ignoreUnfixed: false
              # Optional (only if you have a Trivy config file):
              # trivyConfigPath: "policies/trivy/trivy.yaml"

          # 4) Push image to ECR (only after scan passes)
          - template: pipelines/templates/docker/push-ecr.yml
            parameters:
              imageName: "$(IMAGE_NAME)"
              imageTag: "$(IMAGE_TAG)"
              ecrRegistry: "$(ECR_REGISTRY)"
              pushLatest: true
              additionalTags: ""
              enableImageScanning: true
          - script: |
              set -euo pipefail

              echo "Getting digest for $(ECR_REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)"

              DIGEST="$(aws ecr describe-images \
                --repository-name "$(IMAGE_NAME)" \
                --image-ids imageTag="$(IMAGE_TAG)" \
                --query 'imageDetails[0].imageDigest' \
                --output text)"

              echo "Digest=$DIGEST"
              echo "##vso[task.setvariable variable=IMAGE_DIGEST]$DIGEST"
            displayName: "Get image digest from ECR"
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_REGION: $(AWS_REGION)


          # 5) Keyless cosign sign (must be AFTER push to sign the registry digest)
          - template: pipelines/templates/docker/sign-cosign.yml
            parameters:
              imageName: "$(IMAGE_NAME)"
              imageTag: "$(IMAGE_TAG)"
              imageDigest: "$(IMAGE_DIGEST)"   # <-- الجديد
              ecrRegistry: "$(ECR_REGISTRY)"
              signingMethod: keypair
              cosignKey: "$(COSIGN_PRIVATE_KEY_B64)"





  - stage: DeployDev
    displayName: Deploy to Dev
    dependsOn: BuildAndRelease
    condition: and(succeeded('BuildAndRelease'), eq(variables['Build.SourceBranchName'], 'main'))
    jobs:
      - job: Deploy
        displayName: Deploy Backend to Dev (kubectl apply)
        pool:
          name: Default

        steps:
          - checkout: self

          # 0) Print debug (عشان نتأكد من القيم)
          - script: |
              echo "Build.Reason=$(Build.Reason)"
              echo "Build.SourceBranch=$(Build.SourceBranch)"
              echo "Build.SourceBranchName=$(Build.SourceBranchName)"
              echo "AWS_REGION=$(AWS_REGION)"
              echo "EKS_CLUSTER_NAME=$(EKS_CLUSTER_NAME)"
            displayName: "Debug deploy variables"

          # 1) Install/Verify kubectl (NO sudo)
          - script: |
              set -euo pipefail

              BIN_DIR="$(Pipeline.Workspace)/bin"
              mkdir -p "$BIN_DIR"
              echo "##vso[task.prependpath]$BIN_DIR"

              if command -v kubectl >/dev/null 2>&1; then
                echo "kubectl already exists: $(command -v kubectl)"
                kubectl version --client=true --output=yaml || true
                exit 0
              fi

              if ! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1; then
                echo "##vso[task.logissue type=error]Need curl or wget to download kubectl (no sudo available)."
                exit 1
              fi

              KVER="$(curl -sSfL https://dl.k8s.io/release/stable.txt 2>/dev/null || true)"
              if [ -z "$KVER" ]; then
                KVER="v1.29.0"
              fi

              URL="https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl"
              OUT="$BIN_DIR/kubectl"

              echo "Downloading kubectl $KVER ..."
              if command -v curl >/dev/null 2>&1; then
                curl -sSfL "$URL" -o "$OUT"
              else
                wget -qO "$OUT" "$URL"
              fi

              chmod +x "$OUT"
              kubectl version --client=true --output=yaml || true
            displayName: "Install/Verify kubectl (no sudo)"

          # 2) Configure kubeconfig for EKS
          - script: |
              set -euo pipefail

              : "${AWS_REGION:?AWS_REGION missing}"
              : "${EKS_CLUSTER_NAME:?EKS_CLUSTER_NAME missing}"

              aws --version
              echo "Configuring kubeconfig for cluster: $EKS_CLUSTER_NAME in $AWS_REGION"

              aws eks update-kubeconfig \
                --name "$EKS_CLUSTER_NAME" \
                --region "$AWS_REGION"

              echo "Kubeconfig configured"
              kubectl cluster-info
              kubectl get nodes -o wide
            displayName: "aws eks update-kubeconfig"
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_REGION: $(AWS_REGION)
          - script: |
              set -euo pipefail
              echo "Patching manifest image to digest..."

              IMAGE_WITH_DIGEST="$(ECR_REGISTRY)/$(IMAGE_NAME)@$(IMAGE_DIGEST)"
              echo "IMAGE_WITH_DIGEST=$IMAGE_WITH_DIGEST"

              # استبدال أي image line للصورة بتاعتك
              sed -i "s#image: .*capstone-project-backend.*#image: ${IMAGE_WITH_DIGEST}#g" k8s/dev-backend/backend-deployment.yaml

              echo "Resulting image line:"
              grep "image:" -n k8s/dev-backend/backend-deployment.yaml
            displayName: "Patch manifest to use digest"

          # 3) Deploy backend manifests
          - script: |
              set -euo pipefail

              NS="dev"
              echo "Ensuring namespace: $NS"
              kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create ns "$NS"

              echo "Applying backend manifests..."
              kubectl -n "$NS" apply -f k8s/dev-backend/backend-configmap.yaml
              kubectl -n "$NS" apply -f k8s/dev-backend/backend-deployment.yaml
              kubectl -n "$NS" apply -f k8s/dev-backend/backend-service.yaml

              echo "Rollout status..."
              kubectl -n "$NS" rollout status deploy/backend --timeout=180s || true

              echo "Backend resources:"
              kubectl -n "$NS" get deploy,po,svc -o wide
            displayName: "Deploy backend to dev (kubectl apply)"



