# azure-pipelines-backend.yml
trigger:
  branches:
    include:
      - main
      - release/*
  tags:
    include:
      - v*
  paths:
    include:
      - backend/*

pr:
  branches:
    include:
      - main
  paths:
    include:
      - backend/*

variables:
  - group: aws-credentials
  - group: cosign-secrets
  - name: AWS_REGION
    value: us-east-2

  - name: EKS_CLUSTER_NAME
    value: capstone-project

  # ECR registry base
  - name: ECR_REGISTRY
    value: $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com

  # Repo name in ECR
  - name: IMAGE_NAME
    value: capstone-project-backend

  # Tag: commit SHA
  - name: IMAGE_TAG
    value: $(Build.SourceVersion)

stages:
  - stage: PRChecks
    displayName: PR Fast Checks
    condition: eq(variables['Build.Reason'], 'PullRequest')
    jobs:
      - job: LintAndTest
        displayName: Lint & Test
        pool:
          name: Default
        steps:
          - template: devops/templates/python-pr-checks.yml

  - stage: BuildAndRelease
    displayName: SBOM (source) → Build → Scan → Push → Sign
    condition: ne(variables['Build.Reason'], 'PullRequest')
    jobs:
      - job: Build
        displayName: Backend Build + Security + Push
        pool:
          name: Default
        steps:
          - script: |
              echo "Build.Reason=$(Build.Reason)"
              echo "Build.SourceBranch=$(Build.SourceBranch)"
              echo "Build.SourceBranchName=$(Build.SourceBranchName)"
            displayName: "Debug branch variables"

          - checkout: self
            persistCredentials: true


          # 1) SBOM for backend SOURCE code/dependencies (NOT docker image)
          - template: pipelines/templates/docker/sbom-syft.yml
            parameters:
              sourcePath: backend
              outputFormats: "spdx-json cyclonedx-json"
              attachToImage: false
              artifactName: "sbom-backend-src-$(Build.BuildId)"

          # 2) Build docker image locally (BuildKit)
          - template: pipelines/templates/docker/build-docker.yml
            parameters:
              imageName: "$(IMAGE_NAME)"
              imageTag: "$(IMAGE_TAG)"
              dockerfilePath: backend/Dockerfile
              buildContext: backend
              enableCache: true
              cacheRegistry: "$(ECR_REGISTRY)"
              buildArgs: ""

          # 3) Trivy scan the LOCAL image (before push)
          - template: pipelines/templates/docker/scan-trivy.yml
            parameters:
              imageName: "$(IMAGE_NAME)"
              imageTag: "$(IMAGE_TAG)"
              severityThreshold: "CRITICAL,HIGH"
              failOnVulnerabilities: true
              ignoreUnfixed: false
              # Optional (only if you have a Trivy config file):
              # trivyConfigPath: "policies/trivy/trivy.yaml"

          # 4) Push image to ECR (only after scan passes)
          - template: pipelines/templates/docker/push-ecr.yml
            parameters:
              imageName: "$(IMAGE_NAME)"
              imageTag: "$(IMAGE_TAG)"
              ecrRegistry: "$(ECR_REGISTRY)"
              pushLatest: true
              additionalTags: ""
              enableImageScanning: true

          # 5) Keyless cosign sign (must be AFTER push to sign the registry digest)
          - template: pipelines/templates/docker/sign-cosign.yml
            parameters:
              imageName: "$(IMAGE_NAME)"
              imageTag: "$(IMAGE_TAG)"
              ecrRegistry: "$(ECR_REGISTRY)"
              signingMethod: keypair
              cosignKey: "$(COSIGN_PRIVATE_KEY_B64)"




  - stage: DeployDev
    displayName: Deploy to Dev
    dependsOn: BuildAndRelease
    condition: and(succeeded(), eq(variables['Build.SourceBranchName'], 'main'))
    jobs:
      - job: Deploy
        pool:
          name: Default
        steps:
          - template: pipelines/templates/k8s/deploy-eks.yml
            parameters:
              environment: dev
              namespace: dev
              manifestsPath: k8s/dev-backend
              clusterName: "$(EKS_CLUSTER_NAME)"

