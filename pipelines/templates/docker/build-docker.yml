parameters:
  - name: dockerfilePath
    type: string
    default: "Dockerfile"
  - name: buildContext
    type: string
    default: "."
  - name: imageName
    type: string
  - name: imageTag
    type: string
    default: "$(Build.BuildNumber)"
  - name: buildArgs
    type: object
    default: {}
  - name: enableCache
    type: boolean
    default: true
  - name: cacheRegistry
    type: string
    default: "$(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com"

steps:
  # 0) Ensure prerequisites on CentOS (docker + aws + jq)
  - script: |
      set -euo pipefail

      echo "== OS info =="
      cat /etc/os-release || true

      echo "== Ensure docker is installed =="
      if ! command -v docker >/dev/null 2>&1; then
        echo "Docker not found. Installing..."
        sudo dnf -y install dnf-plugins-core
        sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
        sudo dnf -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
      fi

      echo "== Start/enable docker daemon =="
      sudo systemctl enable --now docker
      sudo systemctl status docker --no-pager || true

      echo "== Ensure current user can access docker =="
      # If the agent user isn't in docker group, docker commands may fail.
      # Add user to docker group and activate group for this session.
      sudo usermod -aG docker "$(whoami)" || true
      if ! docker info >/dev/null 2>&1; then
        echo "Re-trying docker with newgrp docker..."
        newgrp docker <<'EOF'
      docker version
      docker info
EOF
      else
        docker version
        docker info
      fi

      echo "== Ensure aws cli is installed =="
      if ! command -v aws >/dev/null 2>&1; then
        echo "AWS CLI not found. Installing..."
        sudo dnf -y install awscli
      fi
      aws --version

      echo "== Ensure jq is installed =="
      if ! command -v jq >/dev/null 2>&1; then
        sudo dnf -y install jq
      fi
      jq --version
    displayName: "Prereqs (CentOS 10): docker + aws + jq"

  # 1) Login to ECR (more reliable on self-hosted CentOS than Docker@2 login)
  - script: |
      set -euo pipefail

      : "${AWS_REGION:?AWS_REGION is required}"
      : "${AWS_ACCOUNT_ID:?AWS_ACCOUNT_ID is required}"

      REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
      echo "Logging in to ECR: $REGISTRY"

      aws ecr get-login-password --region "${AWS_REGION}" \
        | docker login --username AWS --password-stdin "${REGISTRY}"

      echo "ECR login OK"
    displayName: "Login to ECR (aws ecr get-login-password)"
    env:
      AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
      AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
      AWS_REGION: $(AWS_REGION)
      AWS_ACCOUNT_ID: $(AWS_ACCOUNT_ID)

  # 2) Build Docker image with BuildKit
  - script: |
      set -euo pipefail

      echo "##[section]Building Docker image with BuildKit"
      echo "Image: ${{ parameters.imageName }}:${{ parameters.imageTag }}"
      echo "Dockerfile: ${{ parameters.dockerfilePath }}"
      echo "Context: ${{ parameters.buildContext }}"

      export DOCKER_BUILDKIT=1

      # Prepare build arguments
      BUILD_ARGS=""
      ${{ each arg in parameters.buildArgs }}:
        BUILD_ARGS="$BUILD_ARGS --build-arg ${{ arg.key }}=${{ arg.value }}"
      done

      # Cache configuration
      CACHE_ARGS=""
      if [ "${{ parameters.enableCache }}" = "True" ]; then
        CACHE_FROM_IMAGE="${{ parameters.cacheRegistry }}/${{ parameters.imageName }}:cache"
        echo "Cache enabled from: $CACHE_FROM_IMAGE"
        CACHE_ARGS="--cache-from $CACHE_FROM_IMAGE --build-arg BUILDKIT_INLINE_CACHE=1"
      fi

      docker build \
        -f "${{ parameters.dockerfilePath }}" \
        -t "${{ parameters.imageName }}:${{ parameters.imageTag }}" \
        -t "${{ parameters.imageName }}:latest" \
        $BUILD_ARGS \
        $CACHE_ARGS \
        "${{ parameters.buildContext }}"

      echo "##[section]Build completed successfully"

      IMAGE_SIZE=$(docker images "${{ parameters.imageName }}:${{ parameters.imageTag }}" --format "{{.Size}}")
      echo "##[command]Image size: $IMAGE_SIZE"

      echo "##vso[task.setvariable variable=ImageName;isOutput=true]${{ parameters.imageName }}"
      echo "##vso[task.setvariable variable=ImageTag;isOutput=true]${{ parameters.imageTag }}"
    displayName: "Build Docker Image with BuildKit"
    name: BuildImage
    env:
      DOCKER_BUILDKIT: 1

  # 3) Get image digest (local)
  - script: |
      set -euo pipefail
      DIGEST=$(docker inspect --format='{{index .Id}}' "${{ parameters.imageName }}:${{ parameters.imageTag }}")
      echo "Image Digest: $DIGEST"
      echo "##vso[task.setvariable variable=ImageDigest;isOutput=true]$DIGEST"
    displayName: "Get Image Digest"
    name: ImageInfo

  # 4) Save as artifact
  - script: |
      set -euo pipefail
      docker save -o "$(Build.ArtifactStagingDirectory)/image.tar" "${{ parameters.imageName }}:${{ parameters.imageTag }}"
      ls -lah "$(Build.ArtifactStagingDirectory)/image.tar"
    displayName: "Save Image as Artifact (docker save)"

  - task: PublishPipelineArtifact@1
    displayName: "Publish Docker Image Artifact"
    inputs:
      targetPath: "$(Build.ArtifactStagingDirectory)/image.tar"
      artifact: "docker-image"
      publishLocation: "pipeline"
