# azure-pipelines-infra.yml
# Full DevSecOps Pipeline for Infrastructure & Governance

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - terraform/*
      - k8s/kyverno/*
      - ansible/*

variables:
  - group: "aws-credentials"

  - name: awsRegion
    value: "us-east-2"
  - name: clusterName
    value: "capstone-project"

  # Backend settings (kept as variables so theyâ€™re easy to change)
  - name: tfStateBucket
    value: "capstone-tf-state-1770806700"
  - name: tfStateKey
    value: "final-project/terraform.tfstate"
  - name: tfLockTable
    value: "terraform-lock"

stages:
  # ==========================================
  # Stage 1: IaC Security & Provisioning
  # ==========================================
  - stage: Infrastructure
    displayName: "Terraform & IaC Security"
    jobs:
      - job: Terraform_Plan_Apply
        displayName: "SCA, Plan & Apply"
        pool:
          name: Default
        steps:
          # ------------------------------
          # IaC Security Scan (Trivy)
          # ------------------------------
          - script: |
              set -euxo pipefail
              mkdir -p ~/bin
              export PATH="$PATH:~/bin"

              if ! command -v trivy &> /dev/null; then
                echo "Trivy not found in path, downloading to ~/bin..."
                wget -q https://github.com/aquasecurity/trivy/releases/download/v0.49.1/trivy_0.49.1_Linux-64bit.tar.gz
                tar zxvf trivy_0.49.1_Linux-64bit.tar.gz -C ~/bin/ trivy
                rm trivy_0.49.1_Linux-64bit.tar.gz
              fi

              trivy version
              trivy config terraform/
            displayName: "IaC Security Scan (Trivy)"

          # ------------------------------
          # Diagnostics + Backend checks + Init
          # ------------------------------
          - script: |
              set -euxo pipefail

              echo "== Repo diagnostics =="
              git log -1 --oneline || true
              df -h || true
              ls -la || true
              ls -la modules/logging/ || true
              test -f modules/logging/main.tf && sed -n '1,200p' modules/logging/main.tf || true
              test -f backend.tf && sed -n '1,200p' backend.tf || true

              echo "== Remote backend diagnostics (S3 + DynamoDB) =="
              aws --version
              aws s3api head-object \
                --bucket "$(tfStateBucket)" \
                --key "$(tfStateKey)" \
                --region "$(awsRegion)" || true

              # aws dynamodb scan \
              #   --table-name "$(tfLockTable)" \
              #   --region "$(awsRegion)" \
              #   --max-items 50 || true

              echo "== Clean local terraform cache =="
              rm -rf .terraform .terraform.lock.hcl

              echo "== Terraform init (with retry) =="
              for i in 1 2 3; do
                echo "Attempt $i/3"
                if terraform init -input=false -reconfigure -no-color \
                  -backend-config="bucket=$(tfStateBucket)" \
                  -backend-config="key=$(tfStateKey)" \
                  -backend-config="region=$(awsRegion)"; then
                  break
                fi
                echo "terraform init failed. Sleeping 20s then retry..."
                sleep 20
              done
            displayName: "Terraform Init & Exhaustive Diagnostics"
            workingDirectory: "terraform"
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # ------------------------------
          # Validate
          # ------------------------------
          - script: |
              set -euxo pipefail
              terraform validate -no-color
            displayName: "Terraform Validate"
            workingDirectory: "terraform"
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # ------------------------------
          # Plan
          # ------------------------------
          - script: |
              set -euxo pipefail
              terraform plan -input=false -out=tfplan -no-color
            displayName: "Terraform Plan"
            workingDirectory: "terraform"
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          # ------------------------------
          # Apply (main only)
          # ------------------------------
          - script: |
              set -euxo pipefail
              terraform apply -input=false -auto-approve tfplan -no-color
            displayName: "Terraform Apply"
            condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
            workingDirectory: "terraform"
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

  # ==========================================
  # Stage 2: Governance (Kyverno)
  # ==========================================
  - stage: Governance
    displayName: "Kyverno Policy Enforcement"
    dependsOn: Infrastructure
    jobs:
      - job: Setup_Kyverno
        displayName: "Install Kyverno & Apply Policies"
        pool:
          name: Default
        steps:

          - script: |
              set -euxo pipefail

              echo "== Check kyverno release status =="
              helm -n kyverno status kyverno || true
              helm -n kyverno history kyverno || true

              # Get release status if exists
              status="$(helm -n kyverno status kyverno 2>/dev/null | awk -F': ' '/^STATUS:/{print $2}' || true)"
              echo "Detected STATUS: ${status:-<none>}"

              if [[ "$status" == pending-install || "$status" == pending-upgrade || "$status" == pending-rollback ]]; then
                echo "Release is pending. Attempting rollback to last successful revision..."

                # Find last deployed revision number (if any)
                last_deployed="$(helm -n kyverno history kyverno 2>/dev/null | awk '$3=="deployed"{rev=$1} END{print rev}' || true)"
                if [[ -n "${last_deployed:-}" ]]; then
                  echo "Rolling back to revision: $last_deployed"
                  helm -n kyverno rollback kyverno "$last_deployed" --wait --timeout 15m || true
                else
                  echo "No deployed revision found. Uninstalling stuck release..."
                  helm -n kyverno uninstall kyverno || true
                fi
              fi
            displayName: "Fix Helm pending operation (Kyverno)"

          - script: |
              set -euxo pipefail
              aws eks update-kubeconfig --name "$(clusterName)" --region "$(awsRegion)"
            displayName: "Update Kubeconfig"
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          - script: |
              set -euxo pipefail

              echo "== Check if Kyverno is already installed =="

              if helm status kyverno -n kyverno >/dev/null 2>&1; then
                echo "Kyverno already installed. Checking health..."

                kubectl -n kyverno get deploy,po

                # Check if admission controller is ready
                if kubectl -n kyverno rollout status deploy/kyverno-admission-controller --timeout=30s; then
                  echo "Kyverno is healthy. Skipping install."
                  exit 0
                else
                  echo "Kyverno exists but not healthy. Reinstalling..."
                fi
              fi

              echo "== Installing Kyverno =="

              helm repo add kyverno https://kyverno.github.io/kyverno/ || true
              helm repo update

              helm upgrade --install kyverno kyverno/kyverno \
                --version 3.3.4 \
                -n kyverno --create-namespace \
                --set image.tag="v1.12.7" \
                -f k8s/kyverno/kyverno-values.yaml \
                --wait --timeout 8m


              echo "Kyverno installation complete."
            displayName: "Install Kyverno (Only if Missing)"



          - script: |
              set -euxo pipefail
              kubectl apply -f k8s/kyverno/policies/
            displayName: "Apply Kyverno Cluster Policies"

  # ==========================================
  # Stage 3: Secrets Management (Vault)
  # ==========================================
  - stage: Vault_Setup
    displayName: "Vault Integration"
    dependsOn: Infrastructure
    jobs:
      - job: Vault_Injector
        displayName: "Install Vault Agent Injector"
        pool:
          name: Default
        steps:
          - script: |
              set -euxo pipefail
              aws eks update-kubeconfig --name "$(clusterName)" --region "$(awsRegion)"
            displayName: "Update Kubeconfig"
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)

          - script: |
              set -euxo pipefail
              helm repo add hashicorp https://helm.releases.hashicorp.com
              helm repo update

              # Assuming Vault Public IP is retrieved from TF output or variable
              VAULT_IP=$(aws ec2 describe-instances \
                --filters "Name=tag:Name,Values=vault-instance" \
                --query "Reservations[].Instances[].PublicIpAddress" \
                --output text)

              echo "Vault IP: $VAULT_IP"

              helm upgrade --install vault hashicorp/vault \
                --set "injector.externalVaultAddr=http://$VAULT_IP:8200" \
                -n vault --create-namespace
            displayName: "Install Vault Agent Injector"
            env:
              AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
              AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
              AWS_DEFAULT_REGION: $(awsRegion)
